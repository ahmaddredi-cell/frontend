"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/layout",{

/***/ "(app-pages-browser)/./lib/api/api-client.ts":
/*!*******************************!*\
  !*** ./lib/api/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\n/* harmony import */ var _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils/notifications */ \"(app-pages-browser)/./lib/utils/notifications.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * API Client Module\r\n * \r\n * This module provides a unified way to interact with the backend API.\r\n * It handles common concerns like:\r\n * - Authentication headers\r\n * - Error handling\r\n * - Request/response interceptors\r\n * - Refreshing tokens\r\n */ \n// API base URL\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:5000/api\";\n// API client class\nclass ApiClient {\n    // Get the authentication token from local storage\n    getAuthToken() {\n        if (true) {\n            return localStorage.getItem(\"authToken\");\n        }\n        return null;\n    }\n    // Set the authentication token in local storage\n    setAuthToken(token) {\n        if (true) {\n            localStorage.setItem(\"authToken\", token);\n            console.log(\"Auth token set, length:\", token.length);\n        }\n    }\n    // Remove the authentication token from local storage\n    removeAuthToken() {\n        if (true) {\n            localStorage.removeItem(\"authToken\");\n            console.log(\"Auth token removed\");\n        }\n    }\n    // Check if the user is authenticated\n    isAuthenticated() {\n        return !!this.getAuthToken();\n    }\n    // Refresh the access token using refresh token\n    async refreshAccessToken() {\n        try {\n            var _data_data;\n            const refreshToken = localStorage.getItem(\"refreshToken\");\n            if (!refreshToken) {\n                console.log(\"No refresh token found\");\n                return false;\n            }\n            console.log(\"Attempting to refresh token\");\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/refresh-token\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    refreshToken\n                }),\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                console.log(\"Token refresh response not OK:\", response.status);\n                return false;\n            }\n            const data = await response.json();\n            console.log(\"Token refresh response:\", data);\n            if (data.success && ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.token)) {\n                this.setAuthToken(data.data.token);\n                // Also update refresh token if provided\n                if (data.data.refreshToken) {\n                    localStorage.setItem(\"refreshToken\", data.data.refreshToken);\n                }\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Failed to refresh token:\", error);\n            return false;\n        }\n    }\n    // Handle API errors\n    async handleError(error, originalRequest) {\n        console.error(\"API Error:\", error);\n        // Network error\n        if (!error.response) {\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(\"خطأ في الاتصال بالخادم\");\n            return {\n                success: false,\n                message: \"خطأ في الاتصال بالخادم\",\n                statusCode: 0\n            };\n        }\n        // Handle different status codes\n        const { status, data } = error.response;\n        if (status === 401) {\n            // Check if this is already a retry after token refresh\n            if (originalRequest && originalRequest.isRetry) {\n                // Token refresh failed or expired again, redirect to login\n                this.removeAuthToken();\n                localStorage.removeItem(\"refreshToken\");\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"انتهت صلاحية الجلسة، يرجى تسجيل الدخول مرة أخرى\",\n                    statusCode: status\n                };\n            }\n            // Try to refresh the token\n            const refreshSuccess = await this.refreshAccessToken();\n            if (refreshSuccess && originalRequest) {\n                // Retry the original request with the new token\n                const { endpoint, method, data, options } = originalRequest;\n                return this.request(endpoint, method, data, options, true);\n            } else {\n                // Refresh failed, redirect to login\n                this.removeAuthToken();\n                localStorage.removeItem(\"refreshToken\");\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"انتهت صلاحية الجلسة، يرجى تسجيل الدخول مرة أخرى\",\n                    statusCode: status\n                };\n            }\n        }\n        if (status === 403) {\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(\"ليس لديك صلاحية للوصول إلى هذا المورد\");\n            return {\n                success: false,\n                message: \"ليس لديك صلاحية للوصول إلى هذا المورد\",\n                statusCode: status\n            };\n        }\n        if (status === 404) {\n            return {\n                success: false,\n                message: \"المورد غير موجود\",\n                statusCode: status\n            };\n        }\n        if (status === 422 || status === 400) {\n            const errorMsg = data.message || \"بيانات غير صالحة\";\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(errorMsg);\n            return {\n                success: false,\n                message: errorMsg,\n                errors: data.errors || [],\n                statusCode: status\n            };\n        }\n        // Default error\n        const errorMsg = data.message || \"حدث خطأ ما\";\n        _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(errorMsg);\n        return {\n            success: false,\n            message: errorMsg,\n            statusCode: status\n        };\n    }\n    // Make an API request\n    async request(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"GET\", data = arguments.length > 2 ? arguments[2] : void 0, options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n            requiresAuth: true\n        }, isRetry = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;\n        const url = \"\".concat(API_BASE_URL).concat(endpoint);\n        const { requiresAuth = true, contentType = \"application/json\" } = options;\n        // Prepare headers\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        // Add authorization header if required\n        if (requiresAuth) {\n            const token = this.getAuthToken();\n            if (!token) {\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"غير مصرح، يرجى تسجيل الدخول\",\n                    statusCode: 401\n                };\n            }\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        // Prepare request options\n        const requestOptions = {\n            method,\n            headers,\n            credentials: \"include\"\n        };\n        // Add body for non-GET requests\n        if (method !== \"GET\" && data) {\n            if (contentType === \"application/json\") {\n                requestOptions.body = JSON.stringify(data);\n            } else if (data instanceof FormData) {\n                requestOptions.body = data;\n                // Remove Content-Type header to let the browser set it with the boundary\n                delete headers[\"Content-Type\"];\n            }\n        }\n        try {\n            console.log(\"Making \".concat(method, \" request to \").concat(url), {\n                requiresAuth,\n                headers\n            });\n            const response = await fetch(url, requestOptions);\n            console.log(\"Response status:\", response.status);\n            const contentType = response.headers.get(\"content-type\");\n            let responseData;\n            if (contentType && contentType.includes(\"application/json\")) {\n                responseData = await response.json();\n                console.log(\"Response data:\", responseData);\n            } else {\n                const text = await response.text();\n                console.log(\"Response text:\", text);\n                try {\n                    responseData = JSON.parse(text);\n                } catch (e) {\n                    responseData = {\n                        message: text\n                    };\n                }\n            }\n            if (!response.ok) {\n                throw {\n                    response: {\n                        status: response.status,\n                        data: responseData\n                    }\n                };\n            }\n            // Handle direct data format or { success, data, message } format\n            if (responseData.success !== undefined) {\n                return {\n                    success: responseData.success,\n                    data: responseData.data,\n                    message: responseData.message,\n                    statusCode: response.status\n                };\n            }\n            // If API returns direct data without wrapping\n            return {\n                success: true,\n                data: responseData,\n                statusCode: response.status\n            };\n        } catch (error) {\n            // Store the original request information for potential retry after token refresh\n            const originalRequest = {\n                endpoint,\n                method,\n                data,\n                options,\n                isRetry\n            };\n            return this.handleError(error, originalRequest);\n        }\n    }\n    // HTTP methods\n    async get(endpoint, options) {\n        return this.request(endpoint, \"GET\", undefined, options);\n    }\n    async post(endpoint, data, options) {\n        return this.request(endpoint, \"POST\", data, options);\n    }\n    async put(endpoint, data, options) {\n        return this.request(endpoint, \"PUT\", data, options);\n    }\n    async patch(endpoint, data, options) {\n        return this.request(endpoint, \"PATCH\", data, options);\n    }\n    async delete(endpoint, options) {\n        return this.request(endpoint, \"DELETE\", undefined, options);\n    }\n    // Upload file(s) with FormData with enhanced debugging\n    async uploadFile(endpoint, formData, options) {\n        // Log what's in the FormData for debugging\n        console.log(\"Uploading file to endpoint:\", endpoint);\n        console.log(\"FormData entries:\");\n        for (const pair of formData.entries()){\n            if (pair[1] instanceof File) {\n                const file = pair[1];\n                console.log(\"- Field: \".concat(pair[0], \", File: \").concat(file.name, \", Type: \").concat(file.type, \", Size: \").concat(file.size, \" bytes\"));\n            } else {\n                console.log(\"- Field: \".concat(pair[0], \", Value: \").concat(pair[1]));\n            }\n        }\n        return this.request(endpoint, \"POST\", formData, {\n            ...options,\n            contentType: \"multipart/form-data\"\n        });\n    }\n}\n// Create and export a singleton instance\nconst apiClient = new ApiClient();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FFcUQ7QUFFdEQsZUFBZTtBQUNmLE1BQU1DLGVBQWVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUFrQnhELG1CQUFtQjtBQUNuQixNQUFNQztJQUNKLGtEQUFrRDtJQUMxQ0MsZUFBOEI7UUFDcEMsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQztRQUM5QjtRQUNBLE9BQU87SUFDVDtJQUVBLGdEQUFnRDtJQUN6Q0MsYUFBYUMsS0FBYSxFQUFRO1FBQ3ZDLElBQUksSUFBa0IsRUFBYTtZQUNqQ0gsYUFBYUksT0FBTyxDQUFDLGFBQWFEO1lBQ2xDRSxRQUFRQyxHQUFHLENBQUMsMkJBQTJCSCxNQUFNSSxNQUFNO1FBQ3JEO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDOUNDLGtCQUF3QjtRQUM3QixJQUFJLElBQWtCLEVBQWE7WUFDakNSLGFBQWFTLFVBQVUsQ0FBQztZQUN4QkosUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtJQUVBLHFDQUFxQztJQUM5Qkksa0JBQTJCO1FBQ2hDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ1gsWUFBWTtJQUM1QjtJQUVBLCtDQUErQztJQUMvQyxNQUFjWSxxQkFBdUM7UUFDbkQsSUFBSTtnQkEwQmtCQztZQXpCcEIsTUFBTUMsZUFBZWIsYUFBYUMsT0FBTyxDQUFDO1lBRTFDLElBQUksQ0FBQ1ksY0FBYztnQkFDakJSLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPO1lBQ1Q7WUFFQUQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTVEsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJyQixjQUFhLHdCQUFzQjtnQkFDakVzQixRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FB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WixLQUFLLE1BQU1xRCxRQUFRRCxTQUFTRSxPQUFPLEdBQUk7WUFDckMsSUFBSUQsSUFBSSxDQUFDLEVBQUUsWUFBWUUsTUFBTTtnQkFDM0IsTUFBTUMsT0FBT0gsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BCdEQsUUFBUUMsR0FBRyxDQUFDLFlBQThCd0QsT0FBbEJILElBQUksQ0FBQyxFQUFFLEVBQUMsWUFBOEJHLE9BQXBCQSxLQUFLQyxJQUFJLEVBQUMsWUFBOEJELE9BQXBCQSxLQUFLRSxJQUFJLEVBQUMsWUFBb0IsT0FBVkYsS0FBS0csSUFBSSxFQUFDO1lBQzlGLE9BQU87Z0JBQ0w1RCxRQUFRQyxHQUFHLENBQUMsWUFBK0JxRCxPQUFuQkEsSUFBSSxDQUFDLEVBQUUsRUFBQyxhQUFtQixPQUFSQSxJQUFJLENBQUMsRUFBRTtZQUNwRDtRQUNGO1FBRUEsT0FBTyxJQUFJLENBQUNyQixPQUFPLENBQUlGLFVBQVUsUUFBUXNCLFVBQVU7WUFDakQsR0FBR3JCLE9BQU87WUFDVk0sYUFBYTtRQUNmO0lBQ0Y7QUFDRjtBQUVBLHlDQUF5QztBQUNsQyxNQUFNdUIsWUFBWSxJQUFJcEUsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpL2FwaS1jbGllbnQudHM/ZDI3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQVBJIENsaWVudCBNb2R1bGVcclxuICogXHJcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgdW5pZmllZCB3YXkgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmFja2VuZCBBUEkuXHJcbiAqIEl0IGhhbmRsZXMgY29tbW9uIGNvbmNlcm5zIGxpa2U6XHJcbiAqIC0gQXV0aGVudGljYXRpb24gaGVhZGVyc1xyXG4gKiAtIEVycm9yIGhhbmRsaW5nXHJcbiAqIC0gUmVxdWVzdC9yZXNwb25zZSBpbnRlcmNlcHRvcnNcclxuICogLSBSZWZyZXNoaW5nIHRva2Vuc1xyXG4gKi9cclxuXHJcbmltcG9ydCBub3RpZmljYXRpb25zIGZyb20gJ0AvbGliL3V0aWxzL25vdGlmaWNhdGlvbnMnO1xyXG5cclxuLy8gQVBJIGJhc2UgVVJMXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGknO1xyXG5cclxuLy8gVHlwZXNcclxuZXhwb3J0IHR5cGUgQXBpUmVzcG9uc2U8VD4gPSB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBkYXRhPzogVDtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XHJcbiAgZXJyb3JzPzogc3RyaW5nW107XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZXF1ZXN0T3B0aW9ucyA9IHtcclxuICByZXF1aXJlc0F1dGg/OiBib29sZWFuO1xyXG4gIGNvbnRlbnRUeXBlPzogc3RyaW5nO1xyXG59O1xyXG5cclxudHlwZSBIdHRwTWV0aG9kID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ1BBVENIJztcclxuXHJcbi8vIEFQSSBjbGllbnQgY2xhc3NcclxuY2xhc3MgQXBpQ2xpZW50IHtcclxuICAvLyBHZXQgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZyb20gbG9jYWwgc3RvcmFnZVxyXG4gIHByaXZhdGUgZ2V0QXV0aFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gaW4gbG9jYWwgc3RvcmFnZVxyXG4gIHB1YmxpYyBzZXRBdXRoVG9rZW4odG9rZW46IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCB0b2tlbik7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoIHRva2VuIHNldCwgbGVuZ3RoOicsIHRva2VuLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZyb20gbG9jYWwgc3RvcmFnZVxyXG4gIHB1YmxpYyByZW1vdmVBdXRoVG9rZW4oKTogdm9pZCB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQXV0aCB0b2tlbiByZW1vdmVkJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkXHJcbiAgcHVibGljIGlzQXV0aGVudGljYXRlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMuZ2V0QXV0aFRva2VuKCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4gdXNpbmcgcmVmcmVzaCB0b2tlblxyXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gcmVmcmVzaCB0b2tlbiBmb3VuZCcpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gcmVmcmVzaCB0b2tlbicpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9yZWZyZXNoLXRva2VuYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2hUb2tlbiB9KSxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVG9rZW4gcmVmcmVzaCByZXNwb25zZSBub3QgT0s6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUb2tlbiByZWZyZXNoIHJlc3BvbnNlOicsIGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLmRhdGE/LnRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5zZXRBdXRoVG9rZW4oZGF0YS5kYXRhLnRva2VuKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBbHNvIHVwZGF0ZSByZWZyZXNoIHRva2VuIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKGRhdGEuZGF0YS5yZWZyZXNoVG9rZW4pIHtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoVG9rZW4nLCBkYXRhLmRhdGEucmVmcmVzaFRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIHRva2VuOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIEFQSSBlcnJvcnNcclxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUVycm9yKGVycm9yOiBhbnksIG9yaWdpbmFsUmVxdWVzdD86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8bmV2ZXI+PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xyXG4gICAgXHJcbiAgICAvLyBOZXR3b3JrIGVycm9yXHJcbiAgICBpZiAoIWVycm9yLnJlc3BvbnNlKSB7XHJcbiAgICAgIG5vdGlmaWNhdGlvbnMuZXJyb3IoJ9iu2LfYoyDZgdmKINin2YTYp9iq2LXYp9mEINio2KfZhNiu2KfYr9mFJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ9iu2LfYoyDZgdmKINin2YTYp9iq2LXYp9mEINio2KfZhNiu2KfYr9mFJyxcclxuICAgICAgICBzdGF0dXNDb2RlOiAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgc3RhdHVzIGNvZGVzXHJcbiAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gZXJyb3IucmVzcG9uc2U7XHJcbiAgICBcclxuICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFscmVhZHkgYSByZXRyeSBhZnRlciB0b2tlbiByZWZyZXNoXHJcbiAgICAgIGlmIChvcmlnaW5hbFJlcXVlc3QgJiYgb3JpZ2luYWxSZXF1ZXN0LmlzUmV0cnkpIHtcclxuICAgICAgICAvLyBUb2tlbiByZWZyZXNoIGZhaWxlZCBvciBleHBpcmVkIGFnYWluLCByZWRpcmVjdCB0byBsb2dpblxyXG4gICAgICAgIHRoaXMucmVtb3ZlQXV0aFRva2VuKCk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ9in2YbYqtmH2Kog2LXZhNin2K3ZitipINin2YTYrNmE2LPYqdiMINmK2LHYrNmJINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINmF2LHYqSDYo9iu2LHZiScsXHJcbiAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIHJlZnJlc2ggdGhlIHRva2VuXHJcbiAgICAgIGNvbnN0IHJlZnJlc2hTdWNjZXNzID0gYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChyZWZyZXNoU3VjY2VzcyAmJiBvcmlnaW5hbFJlcXVlc3QpIHtcclxuICAgICAgICAvLyBSZXRyeSB0aGUgb3JpZ2luYWwgcmVxdWVzdCB3aXRoIHRoZSBuZXcgdG9rZW5cclxuICAgICAgICBjb25zdCB7IGVuZHBvaW50LCBtZXRob2QsIGRhdGEsIG9wdGlvbnMgfSA9IG9yaWdpbmFsUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGVuZHBvaW50LCBtZXRob2QsIGRhdGEsIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFJlZnJlc2ggZmFpbGVkLCByZWRpcmVjdCB0byBsb2dpblxyXG4gICAgICAgIHRoaXMucmVtb3ZlQXV0aFRva2VuKCk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ9in2YbYqtmH2Kog2LXZhNin2K3ZitipINin2YTYrNmE2LPYqdiMINmK2LHYrNmJINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINmF2LHYqSDYo9iu2LHZiScsXHJcbiAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoc3RhdHVzID09PSA0MDMpIHtcclxuICAgICAgbm90aWZpY2F0aW9ucy5lcnJvcign2YTZitizINmE2K/ZitmDINi12YTYp9it2YrYqSDZhNmE2YjYtdmI2YQg2KXZhNmJINmH2LDYpyDYp9mE2YXZiNix2K8nKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiAn2YTZitizINmE2K/ZitmDINi12YTYp9it2YrYqSDZhNmE2YjYtdmI2YQg2KXZhNmJINmH2LDYpyDYp9mE2YXZiNix2K8nLFxyXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ9in2YTZhdmI2LHYryDYutmK2LEg2YXZiNis2YjYrycsXHJcbiAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0dXMgPT09IDQyMiB8fCBzdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICBjb25zdCBlcnJvck1zZyA9IGRhdGEubWVzc2FnZSB8fCAn2KjZitin2YbYp9iqINi62YrYsSDYtdin2YTYrdipJztcclxuICAgICAgbm90aWZpY2F0aW9ucy5lcnJvcihlcnJvck1zZyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNc2csXHJcbiAgICAgICAgZXJyb3JzOiBkYXRhLmVycm9ycyB8fCBbXSxcclxuICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBlcnJvclxyXG4gICAgY29uc3QgZXJyb3JNc2cgPSBkYXRhLm1lc3NhZ2UgfHwgJ9it2K/YqyDYrti32KMg2YXYpyc7XHJcbiAgICBub3RpZmljYXRpb25zLmVycm9yKGVycm9yTXNnKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yTXNnLFxyXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBhbiBBUEkgcmVxdWVzdFxyXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdDxUPihcclxuICAgIGVuZHBvaW50OiBzdHJpbmcsXHJcbiAgICBtZXRob2Q6IEh0dHBNZXRob2QgPSAnR0VUJyxcclxuICAgIGRhdGE/OiBhbnksXHJcbiAgICBvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyA9IHsgcmVxdWlyZXNBdXRoOiB0cnVlIH0sXHJcbiAgICBpc1JldHJ5OiBib29sZWFuID0gZmFsc2VcclxuICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XHJcbiAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xyXG4gICAgY29uc3QgeyByZXF1aXJlc0F1dGggPSB0cnVlLCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJyB9ID0gb3B0aW9ucztcclxuICAgIFxyXG4gICAgLy8gUHJlcGFyZSBoZWFkZXJzXHJcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogY29udGVudFR5cGUsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCBhdXRob3JpemF0aW9uIGhlYWRlciBpZiByZXF1aXJlZFxyXG4gICAgaWYgKHJlcXVpcmVzQXV0aCkge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0QXV0aFRva2VuKCk7XHJcbiAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvbG9naW4nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIG1lc3NhZ2U6ICfYutmK2LEg2YXYtdix2K3YjCDZitix2KzZiSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCcsXHJcbiAgICAgICAgICBzdGF0dXNDb2RlOiA0MDEsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwYXJlIHJlcXVlc3Qgb3B0aW9uc1xyXG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge1xyXG4gICAgICBtZXRob2QsXHJcbiAgICAgIGhlYWRlcnMsXHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCBib2R5IGZvciBub24tR0VUIHJlcXVlc3RzXHJcbiAgICBpZiAobWV0aG9kICE9PSAnR0VUJyAmJiBkYXRhKSB7XHJcbiAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XHJcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xyXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBkYXRhO1xyXG4gICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaGVhZGVyIHRvIGxldCB0aGUgYnJvd3NlciBzZXQgaXQgd2l0aCB0aGUgYm91bmRhcnlcclxuICAgICAgICBkZWxldGUgaGVhZGVyc1snQ29udGVudC1UeXBlJ107XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgTWFraW5nICR7bWV0aG9kfSByZXF1ZXN0IHRvICR7dXJsfWAsIHsgcmVxdWlyZXNBdXRoLCBoZWFkZXJzIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgY29uc29sZS5sb2coYFJlc3BvbnNlIHN0YXR1czpgLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XHJcbiAgICAgIGxldCByZXNwb25zZURhdGE7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xyXG4gICAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgZGF0YTonLCByZXNwb25zZURhdGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHRleHQ6JywgdGV4dCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmVzcG9uc2VEYXRhID0geyBtZXNzYWdlOiB0ZXh0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgcmVzcG9uc2U6IHtcclxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGFuZGxlIGRpcmVjdCBkYXRhIGZvcm1hdCBvciB7IHN1Y2Nlc3MsIGRhdGEsIG1lc3NhZ2UgfSBmb3JtYXRcclxuICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zdWNjZXNzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogcmVzcG9uc2VEYXRhLnN1Y2Nlc3MsXHJcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEuZGF0YSxcclxuICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlRGF0YS5tZXNzYWdlLFxyXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIEFQSSByZXR1cm5zIGRpcmVjdCBkYXRhIHdpdGhvdXQgd3JhcHBpbmdcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcclxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgcmVxdWVzdCBpbmZvcm1hdGlvbiBmb3IgcG90ZW50aWFsIHJldHJ5IGFmdGVyIHRva2VuIHJlZnJlc2hcclxuICAgICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0ge1xyXG4gICAgICAgIGVuZHBvaW50LFxyXG4gICAgICAgIG1ldGhvZCxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgaXNSZXRyeVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG9yaWdpbmFsUmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIVFRQIG1ldGhvZHNcclxuICBwdWJsaWMgYXN5bmMgZ2V0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsICdHRVQnLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIHBvc3Q8VD4oZW5kcG9pbnQ6IHN0cmluZywgZGF0YT86IGFueSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwgJ1BPU1QnLCBkYXRhLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBwdXQ8VD4oZW5kcG9pbnQ6IHN0cmluZywgZGF0YT86IGFueSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwgJ1BVVCcsIGRhdGEsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIHBhdGNoPFQ+KGVuZHBvaW50OiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsICdQQVRDSCcsIGRhdGEsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGRlbGV0ZTxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCAnREVMRVRFJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIFVwbG9hZCBmaWxlKHMpIHdpdGggRm9ybURhdGEgd2l0aCBlbmhhbmNlZCBkZWJ1Z2dpbmdcclxuICBwdWJsaWMgYXN5bmMgdXBsb2FkRmlsZTxUPihlbmRwb2ludDogc3RyaW5nLCBmb3JtRGF0YTogRm9ybURhdGEsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcclxuICAgIC8vIExvZyB3aGF0J3MgaW4gdGhlIEZvcm1EYXRhIGZvciBkZWJ1Z2dpbmdcclxuICAgIGNvbnNvbGUubG9nKCdVcGxvYWRpbmcgZmlsZSB0byBlbmRwb2ludDonLCBlbmRwb2ludCk7XHJcbiAgICBjb25zb2xlLmxvZygnRm9ybURhdGEgZW50cmllczonKTtcclxuICAgIGZvciAoY29uc3QgcGFpciBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcclxuICAgICAgaWYgKHBhaXJbMV0gaW5zdGFuY2VvZiBGaWxlKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IHBhaXJbMV0gYXMgRmlsZTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgLSBGaWVsZDogJHtwYWlyWzBdfSwgRmlsZTogJHtmaWxlLm5hbWV9LCBUeXBlOiAke2ZpbGUudHlwZX0sIFNpemU6ICR7ZmlsZS5zaXplfSBieXRlc2ApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAtIEZpZWxkOiAke3BhaXJbMF19LCBWYWx1ZTogJHtwYWlyWzFdfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsICdQT1NUJywgZm9ybURhdGEsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGVudFR5cGU6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIGFuZCBleHBvcnQgYSBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoKTtcclxuIl0sIm5hbWVzIjpbIm5vdGlmaWNhdGlvbnMiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkFwaUNsaWVudCIsImdldEF1dGhUb2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRBdXRoVG9rZW4iLCJ0b2tlbiIsInNldEl0ZW0iLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwicmVtb3ZlQXV0aFRva2VuIiwicmVtb3ZlSXRlbSIsImlzQXV0aGVudGljYXRlZCIsInJlZnJlc2hBY2Nlc3NUb2tlbiIsImRhdGEiLCJyZWZyZXNoVG9rZW4iLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlZGVudGlhbHMiLCJvayIsInN0YXR1cyIsImpzb24iLCJzdWNjZXNzIiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9yaWdpbmFsUmVxdWVzdCIsIm1lc3NhZ2UiLCJzdGF0dXNDb2RlIiwiaXNSZXRyeSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInJlZnJlc2hTdWNjZXNzIiwiZW5kcG9pbnQiLCJvcHRpb25zIiwicmVxdWVzdCIsImVycm9yTXNnIiwiZXJyb3JzIiwicmVxdWlyZXNBdXRoIiwidXJsIiwiY29udGVudFR5cGUiLCJyZXF1ZXN0T3B0aW9ucyIsIkZvcm1EYXRhIiwiZ2V0IiwicmVzcG9uc2VEYXRhIiwiaW5jbHVkZXMiLCJ0ZXh0IiwicGFyc2UiLCJlIiwidW5kZWZpbmVkIiwicG9zdCIsInB1dCIsInBhdGNoIiwiZGVsZXRlIiwidXBsb2FkRmlsZSIsImZvcm1EYXRhIiwicGFpciIsImVudHJpZXMiLCJGaWxlIiwiZmlsZSIsIm5hbWUiLCJ0eXBlIiwic2l6ZSIsImFwaUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api/api-client.ts\n"));

/***/ })

});
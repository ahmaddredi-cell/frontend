"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/layout",{

/***/ "(app-pages-browser)/./lib/api/api-client.ts":
/*!*******************************!*\
  !*** ./lib/api/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\n/* harmony import */ var _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils/notifications */ \"(app-pages-browser)/./lib/utils/notifications.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * API Client Module\r\n * \r\n * This module provides a unified way to interact with the backend API.\r\n * It handles common concerns like:\r\n * - Authentication headers\r\n * - Error handling\r\n * - Request/response interceptors\r\n * - Refreshing tokens\r\n */ \n// API base URL\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:5000/api\";\n// API client class\nclass ApiClient {\n    // Get the authentication token from local storage\n    getAuthToken() {\n        if (true) {\n            return localStorage.getItem(\"authToken\");\n        }\n        return null;\n    }\n    // Set the authentication token in local storage\n    setAuthToken(token) {\n        if (true) {\n            localStorage.setItem(\"authToken\", token);\n            console.log(\"Auth token set, length:\", token.length);\n        }\n    }\n    // Remove the authentication token from local storage\n    removeAuthToken() {\n        if (true) {\n            localStorage.removeItem(\"authToken\");\n            console.log(\"Auth token removed\");\n        }\n    }\n    // Check if the user is authenticated\n    isAuthenticated() {\n        return !!this.getAuthToken();\n    }\n    // Refresh the access token using refresh token\n    async refreshAccessToken() {\n        try {\n            var _data_data;\n            const refreshToken = localStorage.getItem(\"refreshToken\");\n            if (!refreshToken) {\n                console.log(\"No refresh token found\");\n                return false;\n            }\n            console.log(\"Attempting to refresh token\");\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/refresh-token\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    refreshToken\n                }),\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                console.log(\"Token refresh response not OK:\", response.status);\n                return false;\n            }\n            const data = await response.json();\n            console.log(\"Token refresh response:\", data);\n            if (data.success && ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.token)) {\n                this.setAuthToken(data.data.token);\n                // Also update refresh token if provided\n                if (data.data.refreshToken) {\n                    localStorage.setItem(\"refreshToken\", data.data.refreshToken);\n                }\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Failed to refresh token:\", error);\n            return false;\n        }\n    }\n    // Handle API errors\n    async handleError(error, originalRequest) {\n        console.error(\"API Error:\", error);\n        // Network error\n        if (!error.response) {\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(\"خطأ في الاتصال بالخادم\");\n            return {\n                success: false,\n                message: \"خطأ في الاتصال بالخادم\",\n                statusCode: 0\n            };\n        }\n        // Handle different status codes\n        const { status, data } = error.response;\n        if (status === 401) {\n            // Check if this is already a retry after token refresh\n            if (originalRequest && originalRequest.isRetry) {\n                // Token refresh failed or expired again, redirect to login\n                this.removeAuthToken();\n                localStorage.removeItem(\"refreshToken\");\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"انتهت صلاحية الجلسة، يرجى تسجيل الدخول مرة أخرى\",\n                    statusCode: status\n                };\n            }\n            // Try to refresh the token\n            const refreshSuccess = await this.refreshAccessToken();\n            if (refreshSuccess && originalRequest) {\n                // Retry the original request with the new token\n                const { endpoint, method, data, options } = originalRequest;\n                return this.request(endpoint, method, data, options, true);\n            } else {\n                // Refresh failed, redirect to login\n                this.removeAuthToken();\n                localStorage.removeItem(\"refreshToken\");\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"انتهت صلاحية الجلسة، يرجى تسجيل الدخول مرة أخرى\",\n                    statusCode: status\n                };\n            }\n        }\n        if (status === 403) {\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(\"ليس لديك صلاحية للوصول إلى هذا المورد\");\n            return {\n                success: false,\n                message: \"ليس لديك صلاحية للوصول إلى هذا المورد\",\n                statusCode: status\n            };\n        }\n        if (status === 404) {\n            return {\n                success: false,\n                message: \"المورد غير موجود\",\n                statusCode: status\n            };\n        }\n        if (status === 422 || status === 400) {\n            const errorMsg = data.message || \"بيانات غير صالحة\";\n            _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(errorMsg);\n            return {\n                success: false,\n                message: errorMsg,\n                errors: data.errors || [],\n                statusCode: status\n            };\n        }\n        // Default error\n        const errorMsg = data.message || \"حدث خطأ ما\";\n        _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(errorMsg);\n        return {\n            success: false,\n            message: errorMsg,\n            statusCode: status\n        };\n    }\n    // Make an API request\n    async request(endpoint) {\n        let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"GET\", data = arguments.length > 2 ? arguments[2] : void 0, options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n            requiresAuth: true\n        }, isRetry = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;\n        const url = \"\".concat(API_BASE_URL).concat(endpoint);\n        const { requiresAuth = true, contentType = \"application/json\" } = options;\n        // Prepare headers\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        // Add authorization header if required\n        if (requiresAuth) {\n            const token = this.getAuthToken();\n            if (!token) {\n                window.location.href = \"/login\";\n                return {\n                    success: false,\n                    message: \"غير مصرح، يرجى تسجيل الدخول\",\n                    statusCode: 401\n                };\n            }\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        // Prepare request options\n        const requestOptions = {\n            method,\n            headers,\n            credentials: \"include\"\n        };\n        // Add body for non-GET requests\n        if (method !== \"GET\" && data) {\n            if (contentType === \"application/json\") {\n                requestOptions.body = JSON.stringify(data);\n            } else if (data instanceof FormData) {\n                requestOptions.body = data;\n                // Remove Content-Type header to let the browser set it with the boundary\n                delete headers[\"Content-Type\"];\n            }\n        }\n        try {\n            console.log(\"Making \".concat(method, \" request to \").concat(url), {\n                requiresAuth,\n                headers\n            });\n            const response = await fetch(url, requestOptions);\n            console.log(\"Response status:\", response.status);\n            const contentType = response.headers.get(\"content-type\");\n            let responseData;\n            if (contentType && contentType.includes(\"application/json\")) {\n                responseData = await response.json();\n                console.log(\"Response data:\", responseData);\n            } else {\n                const text = await response.text();\n                console.log(\"Response text:\", text);\n                try {\n                    responseData = JSON.parse(text);\n                } catch (e) {\n                    responseData = {\n                        message: text\n                    };\n                }\n            }\n            if (!response.ok) {\n                throw {\n                    response: {\n                        status: response.status,\n                        data: responseData\n                    }\n                };\n            }\n            // Handle direct data format or { success, data, message } format\n            if (responseData.success !== undefined) {\n                return {\n                    success: responseData.success,\n                    data: responseData.data,\n                    message: responseData.message,\n                    statusCode: response.status\n                };\n            }\n            // If API returns direct data without wrapping\n            return {\n                success: true,\n                data: responseData,\n                statusCode: response.status\n            };\n        } catch (error) {\n            // Store the original request information for potential retry after token refresh\n            const originalRequest = {\n                endpoint,\n                method,\n                data,\n                options,\n                isRetry\n            };\n            return this.handleError(error, originalRequest);\n        }\n    }\n    // HTTP methods\n    async get(endpoint, options) {\n        return this.request(endpoint, \"GET\", undefined, options);\n    }\n    async post(endpoint, data, options) {\n        return this.request(endpoint, \"POST\", data, options);\n    }\n    async put(endpoint, data, options) {\n        return this.request(endpoint, \"PUT\", data, options);\n    }\n    async patch(endpoint, data, options) {\n        return this.request(endpoint, \"PATCH\", data, options);\n    }\n    async delete(endpoint, options) {\n        return this.request(endpoint, \"DELETE\", undefined, options);\n    }\n    // Upload file(s) with FormData with enhanced debugging\n    async uploadFile(endpoint, formData, options) {\n        // Log what's in the FormData for debugging\n        console.log(\"Uploading file to endpoint:\", endpoint);\n        // Get the file from attachment field (works around TypeScript iteration issues)\n        const file = formData.get(\"attachment\");\n        if (file instanceof File) {\n            console.log(\"Uploading file: \".concat(file.name, \", Type: \").concat(file.type, \", Size: \").concat(file.size, \" bytes\"));\n        } else {\n            console.warn('No file found in FormData or not using the \"attachment\" field name');\n        }\n        return this.request(endpoint, \"POST\", formData, {\n            ...options,\n            contentType: \"multipart/form-data\"\n        });\n    }\n}\n// Create and export a singleton instance\nconst apiClient = new ApiClient();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FFcUQ7QUFFdEQsZUFBZTtBQUNmLE1BQU1DLGVBQWVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUFrQnhELG1CQUFtQjtBQUNuQixNQUFNQztJQUNKLGtEQUFrRDtJQUMxQ0MsZUFBOEI7UUFDcEMsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQztRQUM5QjtRQUNBLE9BQU87SUFDVDtJQUVBLGdEQUFnRDtJQUN6Q0MsYUFBYUMsS0FBYSxFQUFRO1FBQ3ZDLElBQUksSUFBa0IsRUFBYTtZQUNqQ0gsYUFBYUksT0FBTyxDQUFDLGFBQWFEO1lBQ2xDRSxRQUFRQyxHQUFHLENBQUMsMkJBQTJCSCxNQUFNSSxNQUFNO1FBQ3JEO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDOUNDLGtCQUF3QjtRQUM3QixJQUFJLElBQWtCLEVBQWE7WUFDakNSLGFBQWFTLFVBQVUsQ0FBQztZQUN4QkosUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtJQUVBLHFDQUFxQztJQUM5Qkksa0JBQTJCO1FBQ2hDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ1gsWUFBWTtJQUM1QjtJQUVBLCtDQUErQztJQUMvQyxNQUFjWSxxQkFBdUM7UUFDbkQsSUFBSTtnQkEwQmtCQztZQXpCcEIsTUFBTUMsZUFBZWIsYUFBYUMsT0FBTyxDQUFDO1lBRTFDLElBQUksQ0FBQ1ksY0FBYztnQkFDakJSLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPO1lBQ1Q7WUFFQUQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTVEsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJyQixjQUFhLHdCQUFzQjtnQkFDakVzQixRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FB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QUFPRCxTQUFTWixHQUFHLENBQUM7UUFDMUIsSUFBSWEsZ0JBQWdCQyxNQUFNO1lBQ3hCdkQsUUFBUUMsR0FBRyxDQUFDLG1CQUF1Q3FELE9BQXBCQSxLQUFLRSxJQUFJLEVBQUMsWUFBOEJGLE9BQXBCQSxLQUFLRyxJQUFJLEVBQUMsWUFBb0IsT0FBVkgsS0FBS0ksSUFBSSxFQUFDO1FBQ25GLE9BQU87WUFDTDFELFFBQVEyRCxJQUFJLENBQUM7UUFDZjtRQUVBLE9BQU8sSUFBSSxDQUFDMUIsT0FBTyxDQUFJRixVQUFVLFFBQVFzQixVQUFVO1lBQ2pELEdBQUdyQixPQUFPO1lBQ1ZNLGFBQWE7UUFDZjtJQUNGO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDbEMsTUFBTXNCLFlBQVksSUFBSW5FLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS9hcGktY2xpZW50LnRzP2QyNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEFQSSBDbGllbnQgTW9kdWxlXHJcbiAqIFxyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIHVuaWZpZWQgd2F5IHRvIGludGVyYWN0IHdpdGggdGhlIGJhY2tlbmQgQVBJLlxyXG4gKiBJdCBoYW5kbGVzIGNvbW1vbiBjb25jZXJucyBsaWtlOlxyXG4gKiAtIEF1dGhlbnRpY2F0aW9uIGhlYWRlcnNcclxuICogLSBFcnJvciBoYW5kbGluZ1xyXG4gKiAtIFJlcXVlc3QvcmVzcG9uc2UgaW50ZXJjZXB0b3JzXHJcbiAqIC0gUmVmcmVzaGluZyB0b2tlbnNcclxuICovXHJcblxyXG5pbXBvcnQgbm90aWZpY2F0aW9ucyBmcm9tICdAL2xpYi91dGlscy9ub3RpZmljYXRpb25zJztcclxuXHJcbi8vIEFQSSBiYXNlIFVSTFxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjUwMDAvYXBpJztcclxuXHJcbi8vIFR5cGVzXHJcbmV4cG9ydCB0eXBlIEFwaVJlc3BvbnNlPFQ+ID0ge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZGF0YT86IFQ7XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xyXG4gIGVycm9ycz86IHN0cmluZ1tdO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnMgPSB7XHJcbiAgcmVxdWlyZXNBdXRoPzogYm9vbGVhbjtcclxuICBjb250ZW50VHlwZT86IHN0cmluZztcclxufTtcclxuXHJcbnR5cGUgSHR0cE1ldGhvZCA9ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJyB8ICdQQVRDSCc7XHJcblxyXG4vLyBBUEkgY2xpZW50IGNsYXNzXHJcbmNsYXNzIEFwaUNsaWVudCB7XHJcbiAgLy8gR2V0IHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiBmcm9tIGxvY2FsIHN0b3JhZ2VcclxuICBwcml2YXRlIGdldEF1dGhUb2tlbigpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBTZXQgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIGluIGxvY2FsIHN0b3JhZ2VcclxuICBwdWJsaWMgc2V0QXV0aFRva2VuKHRva2VuOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aFRva2VuJywgdG9rZW4pO1xyXG4gICAgICBjb25zb2xlLmxvZygnQXV0aCB0b2tlbiBzZXQsIGxlbmd0aDonLCB0b2tlbi5sZW5ndGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiBmcm9tIGxvY2FsIHN0b3JhZ2VcclxuICBwdWJsaWMgcmVtb3ZlQXV0aFRva2VuKCk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgY29uc29sZS5sb2coJ0F1dGggdG9rZW4gcmVtb3ZlZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZFxyXG4gIHB1YmxpYyBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gISF0aGlzLmdldEF1dGhUb2tlbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIHVzaW5nIHJlZnJlc2ggdG9rZW5cclxuICBwcml2YXRlIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ05vIHJlZnJlc2ggdG9rZW4gZm91bmQnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHJlZnJlc2ggdG9rZW4nKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2F1dGgvcmVmcmVzaC10b2tlbmAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZWZyZXNoVG9rZW4gfSksXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rva2VuIHJlZnJlc2ggcmVzcG9uc2Ugbm90IE9LOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVG9rZW4gcmVmcmVzaCByZXNwb25zZTonLCBkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS5kYXRhPy50b2tlbikge1xyXG4gICAgICAgIHRoaXMuc2V0QXV0aFRva2VuKGRhdGEuZGF0YS50b2tlbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWxzbyB1cGRhdGUgcmVmcmVzaCB0b2tlbiBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmIChkYXRhLmRhdGEucmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5kYXRhLnJlZnJlc2hUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCB0b2tlbjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEhhbmRsZSBBUEkgZXJyb3JzXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVFcnJvcihlcnJvcjogYW55LCBvcmlnaW5hbFJlcXVlc3Q/OiBhbnkpOiBQcm9taXNlPEFwaVJlc3BvbnNlPG5ldmVyPj4ge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yOicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgLy8gTmV0d29yayBlcnJvclxyXG4gICAgaWYgKCFlcnJvci5yZXNwb25zZSkge1xyXG4gICAgICBub3RpZmljYXRpb25zLmVycm9yKCfYrti32KMg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYrtin2K/ZhScpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICfYrti32KMg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYrtin2K/ZhScsXHJcbiAgICAgICAgc3RhdHVzQ29kZTogMCxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHN0YXR1cyBjb2Rlc1xyXG4gICAgY29uc3QgeyBzdGF0dXMsIGRhdGEgfSA9IGVycm9yLnJlc3BvbnNlO1xyXG4gICAgXHJcbiAgICBpZiAoc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbHJlYWR5IGEgcmV0cnkgYWZ0ZXIgdG9rZW4gcmVmcmVzaFxyXG4gICAgICBpZiAob3JpZ2luYWxSZXF1ZXN0ICYmIG9yaWdpbmFsUmVxdWVzdC5pc1JldHJ5KSB7XHJcbiAgICAgICAgLy8gVG9rZW4gcmVmcmVzaCBmYWlsZWQgb3IgZXhwaXJlZCBhZ2FpbiwgcmVkaXJlY3QgdG8gbG9naW5cclxuICAgICAgICB0aGlzLnJlbW92ZUF1dGhUb2tlbigpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvbG9naW4nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIG1lc3NhZ2U6ICfYp9mG2KrZh9iqINi12YTYp9it2YrYqSDYp9mE2KzZhNiz2KnYjCDZitix2KzZiSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDZhdix2Kkg2KPYrtix2YknLFxyXG4gICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSB0byByZWZyZXNoIHRoZSB0b2tlblxyXG4gICAgICBjb25zdCByZWZyZXNoU3VjY2VzcyA9IGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocmVmcmVzaFN1Y2Nlc3MgJiYgb3JpZ2luYWxSZXF1ZXN0KSB7XHJcbiAgICAgICAgLy8gUmV0cnkgdGhlIG9yaWdpbmFsIHJlcXVlc3Qgd2l0aCB0aGUgbmV3IHRva2VuXHJcbiAgICAgICAgY29uc3QgeyBlbmRwb2ludCwgbWV0aG9kLCBkYXRhLCBvcHRpb25zIH0gPSBvcmlnaW5hbFJlcXVlc3Q7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChlbmRwb2ludCwgbWV0aG9kLCBkYXRhLCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBSZWZyZXNoIGZhaWxlZCwgcmVkaXJlY3QgdG8gbG9naW5cclxuICAgICAgICB0aGlzLnJlbW92ZUF1dGhUb2tlbigpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvbG9naW4nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgIG1lc3NhZ2U6ICfYp9mG2KrZh9iqINi12YTYp9it2YrYqSDYp9mE2KzZhNiz2KnYjCDZitix2KzZiSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDZhdix2Kkg2KPYrtix2YknLFxyXG4gICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XHJcbiAgICAgIG5vdGlmaWNhdGlvbnMuZXJyb3IoJ9mE2YrYsyDZhNiv2YrZgyDYtdmE2KfYrdmK2Kkg2YTZhNmI2LXZiNmEINil2YTZiSDZh9iw2Kcg2KfZhNmF2YjYsdivJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ9mE2YrYsyDZhNiv2YrZgyDYtdmE2KfYrdmK2Kkg2YTZhNmI2LXZiNmEINil2YTZiSDZh9iw2Kcg2KfZhNmF2YjYsdivJyxcclxuICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChzdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICfYp9mE2YXZiNix2K8g2LrZitixINmF2YjYrNmI2K8nLFxyXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdHVzID09PSA0MjIgfHwgc3RhdHVzID09PSA0MDApIHtcclxuICAgICAgY29uc3QgZXJyb3JNc2cgPSBkYXRhLm1lc3NhZ2UgfHwgJ9io2YrYp9mG2KfYqiDYutmK2LEg2LXYp9mE2K3YqSc7XHJcbiAgICAgIG5vdGlmaWNhdGlvbnMuZXJyb3IoZXJyb3JNc2cpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTXNnLFxyXG4gICAgICAgIGVycm9yczogZGF0YS5lcnJvcnMgfHwgW10sXHJcbiAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgZXJyb3JcclxuICAgIGNvbnN0IGVycm9yTXNnID0gZGF0YS5tZXNzYWdlIHx8ICfYrdiv2Ksg2K7Yt9ijINmF2KcnO1xyXG4gICAgbm90aWZpY2F0aW9ucy5lcnJvcihlcnJvck1zZyk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvck1zZyxcclxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE1ha2UgYW4gQVBJIHJlcXVlc3RcclxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgbWV0aG9kOiBIdHRwTWV0aG9kID0gJ0dFVCcsXHJcbiAgICBkYXRhPzogYW55LFxyXG4gICAgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7IHJlcXVpcmVzQXV0aDogdHJ1ZSB9LFxyXG4gICAgaXNSZXRyeTogYm9vbGVhbiA9IGZhbHNlXHJcbiAgKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4ge1xyXG4gICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0VfVVJMfSR7ZW5kcG9pbnR9YDtcclxuICAgIGNvbnN0IHsgcmVxdWlyZXNBdXRoID0gdHJ1ZSwgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbicgfSA9IG9wdGlvbnM7XHJcbiAgICBcclxuICAgIC8vIFByZXBhcmUgaGVhZGVyc1xyXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IGNvbnRlbnRUeXBlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgYXV0aG9yaXphdGlvbiBoZWFkZXIgaWYgcmVxdWlyZWRcclxuICAgIGlmIChyZXF1aXJlc0F1dGgpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldEF1dGhUb2tlbigpO1xyXG4gICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2xvZ2luJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBtZXNzYWdlOiAn2LrZitixINmF2LXYsdit2Iwg2YrYsdis2Ykg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQnLFxyXG4gICAgICAgICAgc3RhdHVzQ29kZTogNDAxLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGFyZSByZXF1ZXN0IG9wdGlvbnNcclxuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBoZWFkZXJzLFxyXG4gICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgYm9keSBmb3Igbm9uLUdFVCByZXF1ZXN0c1xyXG4gICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcgJiYgZGF0YSkge1xyXG4gICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xyXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcclxuICAgICAgICByZXF1ZXN0T3B0aW9ucy5ib2R5ID0gZGF0YTtcclxuICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGhlYWRlciB0byBsZXQgdGhlIGJyb3dzZXIgc2V0IGl0IHdpdGggdGhlIGJvdW5kYXJ5XHJcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYE1ha2luZyAke21ldGhvZH0gcmVxdWVzdCB0byAke3VybH1gLCB7IHJlcXVpcmVzQXV0aCwgaGVhZGVycyB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBSZXNwb25zZSBzdGF0dXM6YCwgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xyXG4gICAgICBsZXQgcmVzcG9uc2VEYXRhO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcclxuICAgICAgICByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGRhdGE6JywgcmVzcG9uc2VEYXRhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSB0ZXh0OicsIHRleHQpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHRleHQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHsgbWVzc2FnZTogdGV4dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IHtcclxuICAgICAgICAgIHJlc3BvbnNlOiB7XHJcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEhhbmRsZSBkaXJlY3QgZGF0YSBmb3JtYXQgb3IgeyBzdWNjZXNzLCBkYXRhLCBtZXNzYWdlIH0gZm9ybWF0XHJcbiAgICAgIGlmIChyZXNwb25zZURhdGEuc3VjY2VzcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlRGF0YS5zdWNjZXNzLFxyXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICBtZXNzYWdlOiByZXNwb25zZURhdGEubWVzc2FnZSxcclxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBBUEkgcmV0dXJucyBkaXJlY3QgZGF0YSB3aXRob3V0IHdyYXBwaW5nXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXHJcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHJlcXVlc3QgaW5mb3JtYXRpb24gZm9yIHBvdGVudGlhbCByZXRyeSBhZnRlciB0b2tlbiByZWZyZXNoXHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsUmVxdWVzdCA9IHtcclxuICAgICAgICBlbmRwb2ludCxcclxuICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIGlzUmV0cnlcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBvcmlnaW5hbFJlcXVlc3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSFRUUCBtZXRob2RzXHJcbiAgcHVibGljIGFzeW5jIGdldDxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCAnR0VUJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBwb3N0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsICdQT1NUJywgZGF0YSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgcHV0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsICdQVVQnLCBkYXRhLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBwYXRjaDxUPihlbmRwb2ludDogc3RyaW5nLCBkYXRhPzogYW55LCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCAnUEFUQ0gnLCBkYXRhLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBkZWxldGU8VD4oZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwgJ0RFTEVURScsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGxvYWQgZmlsZShzKSB3aXRoIEZvcm1EYXRhIHdpdGggZW5oYW5jZWQgZGVidWdnaW5nXHJcbiAgcHVibGljIGFzeW5jIHVwbG9hZEZpbGU8VD4oZW5kcG9pbnQ6IHN0cmluZywgZm9ybURhdGE6IEZvcm1EYXRhLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XHJcbiAgICAvLyBMb2cgd2hhdCdzIGluIHRoZSBGb3JtRGF0YSBmb3IgZGVidWdnaW5nXHJcbiAgICBjb25zb2xlLmxvZygnVXBsb2FkaW5nIGZpbGUgdG8gZW5kcG9pbnQ6JywgZW5kcG9pbnQpO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIGZpbGUgZnJvbSBhdHRhY2htZW50IGZpZWxkICh3b3JrcyBhcm91bmQgVHlwZVNjcmlwdCBpdGVyYXRpb24gaXNzdWVzKVxyXG4gICAgY29uc3QgZmlsZSA9IGZvcm1EYXRhLmdldCgnYXR0YWNobWVudCcpO1xyXG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgZmlsZTogJHtmaWxlLm5hbWV9LCBUeXBlOiAke2ZpbGUudHlwZX0sIFNpemU6ICR7ZmlsZS5zaXplfSBieXRlc2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS53YXJuKCdObyBmaWxlIGZvdW5kIGluIEZvcm1EYXRhIG9yIG5vdCB1c2luZyB0aGUgXCJhdHRhY2htZW50XCIgZmllbGQgbmFtZScpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCAnUE9TVCcsIGZvcm1EYXRhLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRlbnRUeXBlOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KCk7XHJcbiJdLCJuYW1lcyI6WyJub3RpZmljYXRpb25zIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlDbGllbnQiLCJnZXRBdXRoVG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0QXV0aFRva2VuIiwidG9rZW4iLCJzZXRJdGVtIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInJlbW92ZUF1dGhUb2tlbiIsInJlbW92ZUl0ZW0iLCJpc0F1dGhlbnRpY2F0ZWQiLCJyZWZyZXNoQWNjZXNzVG9rZW4iLCJkYXRhIiwicmVmcmVzaFRva2VuIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWRlbnRpYWxzIiwib2siLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsImVycm9yIiwiaGFuZGxlRXJyb3IiLCJvcmlnaW5hbFJlcXVlc3QiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsImlzUmV0cnkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJyZWZyZXNoU3VjY2VzcyIsImVuZHBvaW50Iiwib3B0aW9ucyIsInJlcXVlc3QiLCJlcnJvck1zZyIsImVycm9ycyIsInJlcXVpcmVzQXV0aCIsInVybCIsImNvbnRlbnRUeXBlIiwicmVxdWVzdE9wdGlvbnMiLCJGb3JtRGF0YSIsImdldCIsInJlc3BvbnNlRGF0YSIsImluY2x1ZGVzIiwidGV4dCIsInBhcnNlIiwiZSIsInVuZGVmaW5lZCIsInBvc3QiLCJwdXQiLCJwYXRjaCIsImRlbGV0ZSIsInVwbG9hZEZpbGUiLCJmb3JtRGF0YSIsImZpbGUiLCJGaWxlIiwibmFtZSIsInR5cGUiLCJzaXplIiwid2FybiIsImFwaUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api/api-client.ts\n"));

/***/ })

});